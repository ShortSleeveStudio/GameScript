/**
 * Code template generators for different game engines.
 *
 * Generates method stubs and file wrappers for:
 * - Unity (C# with Awaitable)
 * - Godot (GDScript with await)
 * - Unreal (C++ with delegate)
 */

import type { CodeTemplateType } from '../types/messages.js';

export { CodeTemplateType };

/** Method type constants */
export const METHOD_TYPE_CONDITION = 'condition' as const;
export const METHOD_TYPE_ACTION = 'action' as const;

export type MethodType = typeof METHOD_TYPE_CONDITION | typeof METHOD_TYPE_ACTION;

/**
 * Get the method name for a given node ID and method type, formatted for the template.
 *
 * Unity/Unreal use C# style: `Node_123_Condition` / `Node_123_Action`
 * Godot uses GDScript convention: `cond_123` / `act_123`
 */
export function getMethodNameForTemplate(
    nodeId: number,
    methodType: MethodType,
    template: CodeTemplateType
): string {
    if (template === 'godot') {
        return methodType === METHOD_TYPE_CONDITION ? `cond_${nodeId}` : `act_${nodeId}`;
    }
    // Unity/Unreal use C# style
    return `Node_${nodeId}_${methodType === METHOD_TYPE_CONDITION ? 'Condition' : 'Action'}`;
}

/**
 * Get the file extension for a template type.
 */
export function getFileExtension(template: CodeTemplateType): string {
    switch (template) {
        case 'unity':
            return '.cs';
        case 'godot':
            return '.gd';
        case 'unreal':
            return '.cpp';
        default:
            return '.cs';
    }
}

/**
 * Check if a template uses indentation-based syntax (no braces).
 * GDScript uses indentation instead of braces for code blocks.
 */
export function isIndentationBased(template: CodeTemplateType): boolean {
    return template === 'godot';
}

/**
 * Generate a method stub for a condition or action.
 */
export function generateMethodStub(
    methodName: string,
    methodType: MethodType,
    template: CodeTemplateType
): string {
    switch (template) {
        case 'godot':
            return generateGodotStub(methodName, methodType);
        case 'unity':
        case 'unreal':
        default: {
            // Unity/Unreal use Node_123_Condition format, extract nodeId for attributes
            const nodeId = methodName.replace(/^Node_(\d+)_(Condition|Action)$/, '$1');
            const attributeName = methodType === METHOD_TYPE_CONDITION ? 'NodeCondition' : 'NodeAction';
            return template === 'unreal'
                ? generateUnrealStub(methodName, methodType, nodeId)
                : generateUnityStub(methodName, methodType, nodeId, attributeName);
        }
    }
}

/**
 * Generate a conversation file wrapper with initial method.
 */
export function generateConversationFile(
    conversationId: number,
    initialMethod: string,
    template: CodeTemplateType
): string {
    switch (template) {
        case 'unity':
            return generateUnityFile(conversationId, initialMethod);
        case 'godot':
            return generateGodotFile(conversationId, initialMethod);
        case 'unreal':
            return generateUnrealFile(conversationId, initialMethod);
        default:
            return generateUnityFile(conversationId, initialMethod);
    }
}

// =============================================================================
// Unity Templates (C# with Awaitable)
// =============================================================================

function generateUnityStub(
    methodName: string,
    methodType: MethodType,
    nodeId: string,
    attributeName: string
): string {
    if (methodType === METHOD_TYPE_CONDITION) {
        return `    [${attributeName}(${nodeId})]
    public static bool ${methodName}(IDialogueContext ctx)
    {
        // TODO: Implement condition
        return true;
    }`;
    } else {
        return `    [${attributeName}(${nodeId})]
    public static async Awaitable ${methodName}(IDialogueContext ctx, CancellationToken token)
    {
        // TODO: Implement action
    }`;
    }
}

function generateUnityFile(conversationId: number, initialMethod: string): string {
    return `// Auto-generated by GameScript
// Conversation ID: ${conversationId}

using System.Threading;
using GameScript;
using UnityEngine;

public static class Conversation_${conversationId}
{
${initialMethod}
}
`;
}

// =============================================================================
// Godot Templates (GDScript with await)
// =============================================================================

function generateGodotStub(methodName: string, methodType: MethodType): string {
    // GDScript uses naming convention: cond_{nodeId} / act_{nodeId}
    // methodName is already in the correct format (e.g., "cond_8" or "act_8")
    if (methodType === METHOD_TYPE_CONDITION) {
        return `func ${methodName}(ctx: RunnerContext) -> bool:
\t# TODO: Implement condition
\treturn true`;
    } else {
        return `func ${methodName}(ctx: RunnerContext, token: CancellationToken) -> void:
\t# TODO: Implement action
\tpass`;
    }
}

function generateGodotFile(conversationId: number, initialMethod: string): string {
    return `# Auto-generated by GameScript
# Conversation ID: ${conversationId}
extends RefCounted


${initialMethod}
`;
}

// =============================================================================
// Unreal Templates (C++ with delegate)
// =============================================================================

function generateUnrealStub(
    methodName: string,
    methodType: MethodType,
    _nodeId: string
): string {
    if (methodType === METHOD_TYPE_CONDITION) {
        return `    UFUNCTION()
    static bool ${methodName}(const FDialogueContext& Ctx)
    {
        // TODO: Implement condition
        return true;
    }`;
    } else {
        return `    UFUNCTION()
    static void ${methodName}(const FDialogueContext& Ctx, FOnActionComplete OnComplete)
    {
        // TODO: Implement action
        // Call OnComplete.Execute() when done
        OnComplete.Execute();
    }`;
    }
}

function generateUnrealFile(conversationId: number, initialMethod: string): string {
    return `// Auto-generated by GameScript
// Conversation ID: ${conversationId}

#pragma once

#include "CoreMinimal.h"
#include "GameScript/DialogueContext.h"
#include "Conversation_${conversationId}.generated.h"

UCLASS()
class UConversation_${conversationId} : public UObject
{
    GENERATED_BODY()

public:
${initialMethod}
};
`;
}
