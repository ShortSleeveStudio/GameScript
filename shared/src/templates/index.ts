/**
 * Code template generators for different game engines.
 *
 * Generates method stubs and file wrappers for:
 * - Unity (C# with Awaitable)
 * - Godot (C# with callback)
 * - Unreal (C++ with delegate)
 */

import type { CodeTemplateType } from '../types/messages.js';

export { CodeTemplateType };

/**
 * Get the file extension for a template type.
 */
export function getFileExtension(template: CodeTemplateType): string {
    switch (template) {
        case 'unity':
        case 'godot':
            return '.cs';
        case 'unreal':
            return '.cpp';
        default:
            return '.cs';
    }
}

/**
 * Generate a method stub for a condition or action.
 */
export function generateMethodStub(
    methodName: string,
    methodType: 'condition' | 'action',
    template: CodeTemplateType
): string {
    const nodeId = methodName.replace(/^Node_(\d+)_(Condition|Action)$/, '$1');
    const attributeName = methodType === 'condition' ? 'NodeCondition' : 'NodeAction';

    switch (template) {
        case 'unity':
            return generateUnityStub(methodName, methodType, nodeId, attributeName);
        case 'godot':
            return generateGodotStub(methodName, methodType, nodeId, attributeName);
        case 'unreal':
            return generateUnrealStub(methodName, methodType, nodeId);
        default:
            return generateUnityStub(methodName, methodType, nodeId, attributeName);
    }
}

/**
 * Generate a conversation file wrapper with initial method.
 */
export function generateConversationFile(
    conversationId: number,
    initialMethod: string,
    template: CodeTemplateType
): string {
    switch (template) {
        case 'unity':
            return generateUnityFile(conversationId, initialMethod);
        case 'godot':
            return generateGodotFile(conversationId, initialMethod);
        case 'unreal':
            return generateUnrealFile(conversationId, initialMethod);
        default:
            return generateUnityFile(conversationId, initialMethod);
    }
}

// =============================================================================
// Unity Templates (C# with Awaitable)
// =============================================================================

function generateUnityStub(
    methodName: string,
    methodType: 'condition' | 'action',
    nodeId: string,
    attributeName: string
): string {
    if (methodType === 'condition') {
        return `    [${attributeName}(${nodeId})]
    public static bool ${methodName}(IDialogueContext ctx)
    {
        // TODO: Implement condition
        return true;
    }`;
    } else {
        return `    [${attributeName}(${nodeId})]
    public static async Awaitable ${methodName}(IDialogueContext ctx)
    {
        // TODO: Implement action
    }`;
    }
}

function generateUnityFile(conversationId: number, initialMethod: string): string {
    return `// Auto-generated by GameScript
// Conversation ID: ${conversationId}

using GameScript;
using UnityEngine;

public static class Conversation_${conversationId}
{
${initialMethod}
}
`;
}

// =============================================================================
// Godot Templates (C# with callback)
// =============================================================================

function generateGodotStub(
    methodName: string,
    methodType: 'condition' | 'action',
    nodeId: string,
    attributeName: string
): string {
    if (methodType === 'condition') {
        return `    [${attributeName}(${nodeId})]
    public static bool ${methodName}(IDialogueContext ctx)
    {
        // TODO: Implement condition
        return true;
    }`;
    } else {
        return `    [${attributeName}(${nodeId})]
    public static void ${methodName}(IDialogueContext ctx, Action onComplete)
    {
        // TODO: Implement action
        // Call onComplete() when done
        onComplete();
    }`;
    }
}

function generateGodotFile(conversationId: number, initialMethod: string): string {
    return `// Auto-generated by GameScript
// Conversation ID: ${conversationId}

using System;
using GameScript;

public static class Conversation_${conversationId}
{
${initialMethod}
}
`;
}

// =============================================================================
// Unreal Templates (C++ with delegate)
// =============================================================================

function generateUnrealStub(
    methodName: string,
    methodType: 'condition' | 'action',
    _nodeId: string
): string {
    if (methodType === 'condition') {
        return `    UFUNCTION()
    static bool ${methodName}(const FDialogueContext& Ctx)
    {
        // TODO: Implement condition
        return true;
    }`;
    } else {
        return `    UFUNCTION()
    static void ${methodName}(const FDialogueContext& Ctx, FOnActionComplete OnComplete)
    {
        // TODO: Implement action
        // Call OnComplete.Execute() when done
        OnComplete.Execute();
    }`;
    }
}

function generateUnrealFile(conversationId: number, initialMethod: string): string {
    return `// Auto-generated by GameScript
// Conversation ID: ${conversationId}

#pragma once

#include "CoreMinimal.h"
#include "GameScript/DialogueContext.h"
#include "Conversation_${conversationId}.generated.h"

UCLASS()
class UConversation_${conversationId} : public UObject
{
    GENERATED_BODY()

public:
${initialMethod}
};
`;
}
