/**
 * Code template generators for different game engines.
 *
 * Generates method stubs and file wrappers for:
 * - Unity (C# with Awaitable)
 * - Godot (GDScript with await)
 * - Unreal (C++ with NODE_ACTION/NODE_CONDITION macros)
 */

import type { CodeTemplateType } from '../types/messages.js';

export { CodeTemplateType };

/** Method type constants */
export const METHOD_TYPE_CONDITION = 'condition' as const;
export const METHOD_TYPE_ACTION = 'action' as const;

export type MethodType = typeof METHOD_TYPE_CONDITION | typeof METHOD_TYPE_ACTION;

// ============================================================================
// SYNC REQUIRED - Method Naming Conventions
// ============================================================================
//
// Method names MUST be consistent across:
//
// 1. TypeScript: shared/src/templates/index.ts (this file)
//    - getMethodNameForTemplate() generates names for UI/API
//
// 2. Kotlin: plugins/rider/.../handlers/CodeHandlers.kt
//    - findMethod() uses these names to locate symbols
//    - BACKEND_EXTENSIONS determines which languages use backend lookup
//
// 3. C#: plugins/rider/src/dotnet/.../SymbolLookupHost.cs
//    - SymbolFinder looks up symbols by these exact names
//
// Naming patterns by template:
//   - Unity:  Node_{nodeId}_Condition / Node_{nodeId}_Action
//   - Godot:  cond_{nodeId} / act_{nodeId}
//   - Unreal: __NodeCondition_{nodeId}_Impl / __NodeAction_{nodeId}_Impl
//
// The Unreal names are internal - macros NODE_CONDITION(id)/NODE_ACTION(id)
// expand to functions with these names. The backend must search for the
// expanded name, not the macro invocation.
// ============================================================================

/**
 * Get the method name for a given node ID and method type.
 * This returns the name that the language server will recognize.
 *
 * - Unity: `Node_123_Condition` / `Node_123_Action` (C# method names)
 * - Godot: `cond_123` / `act_123` (GDScript function names)
 * - Unreal: `__NodeCondition_123_Impl` / `__NodeAction_123_Impl` (macro-generated internal names)
 */
export function getMethodNameForTemplate(
    nodeId: number,
    methodType: MethodType,
    template: CodeTemplateType
): string {
    if (template === 'godot') {
        return methodType === METHOD_TYPE_CONDITION ? `cond_${nodeId}` : `act_${nodeId}`;
    }
    if (template === 'unreal') {
        // Return the internal function name generated by NODE_CONDITION/NODE_ACTION macros
        // This is what the C++ language server (clangd) sees after macro expansion
        return methodType === METHOD_TYPE_CONDITION
            ? `__NodeCondition_${nodeId}_Impl`
            : `__NodeAction_${nodeId}_Impl`;
    }
    // Unity
    return `Node_${nodeId}_${methodType === METHOD_TYPE_CONDITION ? 'Condition' : 'Action'}`;
}

/**
 * Get the file extension for a template type.
 */
export function getFileExtension(template: CodeTemplateType): string {
    switch (template) {
        case 'unity':
            return '.cs';
        case 'godot':
            return '.gd';
        case 'unreal':
            return '.cpp';
        default:
            return '.cs';
    }
}

// ============================================================================
// SYNC REQUIRED - Insertion Logic
// ============================================================================
//
// The following logic MUST be kept in sync across THREE locations:
//
// 1. TypeScript: shared/src/templates/index.ts (this file)
//    - usesClassWrapper() determines insertion mode
//    - Also used by: plugins/vscode/src/handlers/code/index.ts
//
// 2. Kotlin: plugins/rider/.../handlers/CodeHandlers.kt
//    - Constants: APPEND_SEPARATOR, CLASS_INSERT_PREFIX, CLASS_INSERT_SUFFIX
//    - Function: computeInsertion()
//
// 3. C#: plugins/rider/src/dotnet/.../SymbolLookupHost.cs
//    - Constants: AppendSeparator, ClassInsertPrefix, ClassInsertSuffix
//    - Function: CreateSymbolCore()
//
// Current behavior:
//   - Unity (usesClassWrapper=true): Insert before closing '}' with "\n" prefix/suffix
//   - Godot/Unreal (usesClassWrapper=false): Append to end with "\n\n" separator
//
// If you change insertion behavior, update ALL THREE locations!
// ============================================================================

/**
 * Check if a template uses a class wrapper for methods.
 * - Unity: Methods inside a static class
 * - Godot: Free-standing functions (no class)
 * - Unreal: Free-standing macro functions (no class)
 *
 * This affects insertion behavior:
 * - Class wrapper: Insert before final '}'
 * - No class wrapper: Append to end of file
 */
export function usesClassWrapper(template: CodeTemplateType): boolean {
    return template === 'unity';
}

/**
 * Extract the node ID from a method name.
 * Only needed for Unity and Unreal (Godot embeds nodeId in the method name itself).
 */
function extractNodeId(methodName: string, template: 'unity' | 'unreal'): string {
    let match: RegExpMatchArray | null;

    if (template === 'unreal') {
        // Format: __NodeCondition_123_Impl or __NodeAction_123_Impl
        match = methodName.match(/^__Node(?:Condition|Action)_(\d+)_Impl$/);
    } else {
        // Unity format: Node_123_Condition or Node_123_Action
        match = methodName.match(/^Node_(\d+)_(?:Condition|Action)$/);
    }

    if (!match) {
        console.warn(`[GameScript] Could not extract node ID from method name: ${methodName}`);
        return '0';
    }

    return match[1];
}

/**
 * Generate a method stub for a condition or action.
 */
export function generateMethodStub(
    methodName: string,
    methodType: MethodType,
    template: CodeTemplateType
): string {
    switch (template) {
        case 'godot':
            // Godot: methodName already contains nodeId (e.g., "cond_123")
            return generateGodotStub(methodName, methodType);
        case 'unreal': {
            const nodeId = extractNodeId(methodName, 'unreal');
            return generateUnrealStub(nodeId, methodType);
        }
        case 'unity':
        default: {
            const nodeId = extractNodeId(methodName, 'unity');
            const attributeName = methodType === METHOD_TYPE_CONDITION ? 'NodeCondition' : 'NodeAction';
            return generateUnityStub(methodName, methodType, nodeId, attributeName);
        }
    }
}

/**
 * Generate a conversation file wrapper with initial method.
 */
export function generateConversationFile(
    conversationId: number,
    initialMethod: string,
    template: CodeTemplateType
): string {
    switch (template) {
        case 'unity':
            return generateUnityFile(conversationId, initialMethod);
        case 'godot':
            return generateGodotFile(conversationId, initialMethod);
        case 'unreal':
            return generateUnrealFile(conversationId, initialMethod);
        default:
            return generateUnityFile(conversationId, initialMethod);
    }
}

// =============================================================================
// Unity Templates (C# with Awaitable)
// =============================================================================

function generateUnityStub(
    methodName: string,
    methodType: MethodType,
    nodeId: string,
    attributeName: string
): string {
    if (methodType === METHOD_TYPE_CONDITION) {
        return `    [${attributeName}(${nodeId})]
    public static bool ${methodName}(IDialogueContext ctx)
    {
        // TODO: Implement condition
        return true;
    }`;
    } else {
        return `    [${attributeName}(${nodeId})]
    public static async Awaitable ${methodName}(IDialogueContext ctx, CancellationToken token)
    {
        // TODO: Implement action
    }`;
    }
}

function generateUnityFile(conversationId: number, initialMethod: string): string {
    return `// Auto-generated by GameScript
// Conversation ID: ${conversationId}

using System.Threading;
using GameScript;
using UnityEngine;

public static class Conversation_${conversationId}
{
${initialMethod}
}
`;
}

// =============================================================================
// Godot Templates (GDScript with await)
// =============================================================================

function generateGodotStub(methodName: string, methodType: MethodType): string {
    // GDScript uses naming convention: cond_{nodeId} / act_{nodeId}
    // methodName is already in the correct format (e.g., "cond_8" or "act_8")
    if (methodType === METHOD_TYPE_CONDITION) {
        return `func ${methodName}(ctx: RunnerContext) -> bool:
\t# TODO: Implement condition
\treturn true`;
    } else {
        return `func ${methodName}(ctx: RunnerContext, token: CancellationToken) -> void:
\t# TODO: Implement action
\tpass`;
    }
}

function generateGodotFile(conversationId: number, initialMethod: string): string {
    return `# Auto-generated by GameScript
# Conversation ID: ${conversationId}
extends RefCounted


${initialMethod}
`;
}

// =============================================================================
// Unreal Templates (C++ with NODE_ACTION/NODE_CONDITION macros)
// =============================================================================

function generateUnrealStub(nodeId: string, methodType: MethodType): string {
    // Unreal uses macros that include the function signature.
    // The user provides only the function body.
    // No indentation - these are free-standing functions, not inside a class.
    if (methodType === METHOD_TYPE_CONDITION) {
        return `NODE_CONDITION(${nodeId})
{
    // TODO: Implement condition
    return true;
}`;
    } else {
        return `NODE_ACTION(${nodeId})
{
    // TODO: Implement action
    return nullptr;  // Instant action (return UGameplayTask* for latent)
}`;
    }
}

function generateUnrealFile(conversationId: number, initialMethod: string): string {
    // Unreal uses free-standing macro functions, no class wrapper.
    // The macros handle registration automatically at static init time.
    return `// Auto-generated by GameScript
// Conversation ID: ${conversationId}

#include "CoreMinimal.h"
#include "Attributes.h"
#include "IDialogueContext.h"

// For latent actions, include the task headers you need:
// #include "GameplayTasks/DialogueAction_Delay.h"
// #include "GameplayTasks/DialogueAction_PlayAnim.h"

${initialMethod}
`;
}
