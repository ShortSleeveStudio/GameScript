// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SNAPSHOT_GAMESCRIPT_H_
#define FLATBUFFERS_GENERATED_SNAPSHOT_GAMESCRIPT_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace GameScript {

struct Int32Value;
struct Int32ValueBuilder;

struct FloatValue;
struct FloatValueBuilder;

struct BoolValue;
struct BoolValueBuilder;

struct PropertyTemplate;
struct PropertyTemplateBuilder;

struct NodeProperty;
struct NodePropertyBuilder;

struct ConversationProperty;
struct ConversationPropertyBuilder;

struct Node;
struct NodeBuilder;

struct Edge;
struct EdgeBuilder;

struct Actor;
struct ActorBuilder;

struct Conversation;
struct ConversationBuilder;

struct Localization;
struct LocalizationBuilder;

struct Snapshot;
struct SnapshotBuilder;

struct StringArray;
struct StringArrayBuilder;

enum PropertyValue : uint8_t {
  PropertyValue_NONE = 0,
  PropertyValue_string_val = 1,
  PropertyValue_int_val = 2,
  PropertyValue_decimal_val = 3,
  PropertyValue_bool_val = 4,
  PropertyValue_MIN = PropertyValue_NONE,
  PropertyValue_MAX = PropertyValue_bool_val
};

inline const PropertyValue (&EnumValuesPropertyValue())[5] {
  static const PropertyValue values[] = {
    PropertyValue_NONE,
    PropertyValue_string_val,
    PropertyValue_int_val,
    PropertyValue_decimal_val,
    PropertyValue_bool_val
  };
  return values;
}

inline const char * const *EnumNamesPropertyValue() {
  static const char * const names[6] = {
    "NONE",
    "string_val",
    "int_val",
    "decimal_val",
    "bool_val",
    nullptr
  };
  return names;
}

inline const char *EnumNamePropertyValue(PropertyValue e) {
  if (::flatbuffers::IsOutRange(e, PropertyValue_NONE, PropertyValue_bool_val)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPropertyValue()[index];
}

template<typename T> struct PropertyValueTraits {
  static const PropertyValue enum_value = PropertyValue_NONE;
};

template<> struct PropertyValueTraits<::flatbuffers::String> {
  static const PropertyValue enum_value = PropertyValue_string_val;
};

template<> struct PropertyValueTraits<GameScript::Int32Value> {
  static const PropertyValue enum_value = PropertyValue_int_val;
};

template<> struct PropertyValueTraits<GameScript::FloatValue> {
  static const PropertyValue enum_value = PropertyValue_decimal_val;
};

template<> struct PropertyValueTraits<GameScript::BoolValue> {
  static const PropertyValue enum_value = PropertyValue_bool_val;
};

template <bool B = false>
bool VerifyPropertyValue(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, PropertyValue type);
template <bool B = false>
bool VerifyPropertyValueVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum PropertyType : int8_t {
  PropertyType_String = 0,
  PropertyType_Integer = 1,
  PropertyType_Decimal = 2,
  PropertyType_Boolean = 3,
  PropertyType_MIN = PropertyType_String,
  PropertyType_MAX = PropertyType_Boolean
};

inline const PropertyType (&EnumValuesPropertyType())[4] {
  static const PropertyType values[] = {
    PropertyType_String,
    PropertyType_Integer,
    PropertyType_Decimal,
    PropertyType_Boolean
  };
  return values;
}

inline const char * const *EnumNamesPropertyType() {
  static const char * const names[5] = {
    "String",
    "Integer",
    "Decimal",
    "Boolean",
    nullptr
  };
  return names;
}

inline const char *EnumNamePropertyType(PropertyType e) {
  if (::flatbuffers::IsOutRange(e, PropertyType_String, PropertyType_Boolean)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPropertyType()[index];
}

enum NodeType : int8_t {
  NodeType_Root = 0,
  NodeType_Dialogue = 1,
  NodeType_Logic = 2,
  NodeType_MIN = NodeType_Root,
  NodeType_MAX = NodeType_Logic
};

inline const NodeType (&EnumValuesNodeType())[3] {
  static const NodeType values[] = {
    NodeType_Root,
    NodeType_Dialogue,
    NodeType_Logic
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[4] = {
    "Root",
    "Dialogue",
    "Logic",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (::flatbuffers::IsOutRange(e, NodeType_Root, NodeType_Logic)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

enum EdgeType : int8_t {
  EdgeType_Default = 0,
  EdgeType_Hidden = 1,
  EdgeType_MIN = EdgeType_Default,
  EdgeType_MAX = EdgeType_Hidden
};

inline const EdgeType (&EnumValuesEdgeType())[2] {
  static const EdgeType values[] = {
    EdgeType_Default,
    EdgeType_Hidden
  };
  return values;
}

inline const char * const *EnumNamesEdgeType() {
  static const char * const names[3] = {
    "Default",
    "Hidden",
    nullptr
  };
  return names;
}

inline const char *EnumNameEdgeType(EdgeType e) {
  if (::flatbuffers::IsOutRange(e, EdgeType_Default, EdgeType_Hidden)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEdgeType()[index];
}

struct Int32Value FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Int32ValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct Int32ValueBuilder {
  typedef Int32Value Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Int32Value::VT_VALUE, value, 0);
  }
  explicit Int32ValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Int32Value> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Int32Value>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Int32Value> CreateInt32Value(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t value = 0) {
  Int32ValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct FloatValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  float value() const {
    return GetField<float>(VT_VALUE, 0.0f);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct FloatValueBuilder {
  typedef FloatValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(float value) {
    fbb_.AddElement<float>(FloatValue::VT_VALUE, value, 0.0f);
  }
  explicit FloatValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatValue> CreateFloatValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float value = 0.0f) {
  FloatValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct BoolValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  bool value() const {
    return GetField<uint8_t>(VT_VALUE, 0) != 0;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE, 1) &&
           verifier.EndTable();
  }
};

struct BoolValueBuilder {
  typedef BoolValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(bool value) {
    fbb_.AddElement<uint8_t>(BoolValue::VT_VALUE, static_cast<uint8_t>(value), 0);
  }
  explicit BoolValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoolValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoolValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoolValue> CreateBoolValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool value = false) {
  BoolValueBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

struct PropertyTemplate FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PropertyTemplateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  GameScript::PropertyType type() const {
    return static_cast<GameScript::PropertyType>(GetField<int8_t>(VT_TYPE, 0));
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct PropertyTemplateBuilder {
  typedef PropertyTemplate Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(PropertyTemplate::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(PropertyTemplate::VT_NAME, name);
  }
  void add_type(GameScript::PropertyType type) {
    fbb_.AddElement<int8_t>(PropertyTemplate::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit PropertyTemplateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PropertyTemplate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PropertyTemplate>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PropertyTemplate> CreatePropertyTemplate(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    GameScript::PropertyType type = GameScript::PropertyType_String) {
  PropertyTemplateBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PropertyTemplate> CreatePropertyTemplateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    GameScript::PropertyType type = GameScript::PropertyType_String) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return GameScript::CreatePropertyTemplate(
      _fbb,
      id,
      name__,
      type);
}

struct NodeProperty FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodePropertyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPLATE_IDX = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  int32_t template_idx() const {
    return GetField<int32_t>(VT_TEMPLATE_IDX, 0);
  }
  GameScript::PropertyValue value_type() const {
    return static_cast<GameScript::PropertyValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ::flatbuffers::String *value_as_string_val() const {
    return value_type() == GameScript::PropertyValue_string_val ? static_cast<const ::flatbuffers::String *>(value()) : nullptr;
  }
  const GameScript::Int32Value *value_as_int_val() const {
    return value_type() == GameScript::PropertyValue_int_val ? static_cast<const GameScript::Int32Value *>(value()) : nullptr;
  }
  const GameScript::FloatValue *value_as_decimal_val() const {
    return value_type() == GameScript::PropertyValue_decimal_val ? static_cast<const GameScript::FloatValue *>(value()) : nullptr;
  }
  const GameScript::BoolValue *value_as_bool_val() const {
    return value_type() == GameScript::PropertyValue_bool_val ? static_cast<const GameScript::BoolValue *>(value()) : nullptr;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TEMPLATE_IDX, 4) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyPropertyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ::flatbuffers::String *NodeProperty::value_as<::flatbuffers::String>() const {
  return value_as_string_val();
}

template<> inline const GameScript::Int32Value *NodeProperty::value_as<GameScript::Int32Value>() const {
  return value_as_int_val();
}

template<> inline const GameScript::FloatValue *NodeProperty::value_as<GameScript::FloatValue>() const {
  return value_as_decimal_val();
}

template<> inline const GameScript::BoolValue *NodeProperty::value_as<GameScript::BoolValue>() const {
  return value_as_bool_val();
}

struct NodePropertyBuilder {
  typedef NodeProperty Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_template_idx(int32_t template_idx) {
    fbb_.AddElement<int32_t>(NodeProperty::VT_TEMPLATE_IDX, template_idx, 0);
  }
  void add_value_type(GameScript::PropertyValue value_type) {
    fbb_.AddElement<uint8_t>(NodeProperty::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(NodeProperty::VT_VALUE, value);
  }
  explicit NodePropertyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NodeProperty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NodeProperty>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NodeProperty> CreateNodeProperty(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t template_idx = 0,
    GameScript::PropertyValue value_type = GameScript::PropertyValue_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  NodePropertyBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_template_idx(template_idx);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct ConversationProperty FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConversationPropertyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEMPLATE_IDX = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  int32_t template_idx() const {
    return GetField<int32_t>(VT_TEMPLATE_IDX, 0);
  }
  GameScript::PropertyValue value_type() const {
    return static_cast<GameScript::PropertyValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ::flatbuffers::String *value_as_string_val() const {
    return value_type() == GameScript::PropertyValue_string_val ? static_cast<const ::flatbuffers::String *>(value()) : nullptr;
  }
  const GameScript::Int32Value *value_as_int_val() const {
    return value_type() == GameScript::PropertyValue_int_val ? static_cast<const GameScript::Int32Value *>(value()) : nullptr;
  }
  const GameScript::FloatValue *value_as_decimal_val() const {
    return value_type() == GameScript::PropertyValue_decimal_val ? static_cast<const GameScript::FloatValue *>(value()) : nullptr;
  }
  const GameScript::BoolValue *value_as_bool_val() const {
    return value_type() == GameScript::PropertyValue_bool_val ? static_cast<const GameScript::BoolValue *>(value()) : nullptr;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TEMPLATE_IDX, 4) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyPropertyValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ::flatbuffers::String *ConversationProperty::value_as<::flatbuffers::String>() const {
  return value_as_string_val();
}

template<> inline const GameScript::Int32Value *ConversationProperty::value_as<GameScript::Int32Value>() const {
  return value_as_int_val();
}

template<> inline const GameScript::FloatValue *ConversationProperty::value_as<GameScript::FloatValue>() const {
  return value_as_decimal_val();
}

template<> inline const GameScript::BoolValue *ConversationProperty::value_as<GameScript::BoolValue>() const {
  return value_as_bool_val();
}

struct ConversationPropertyBuilder {
  typedef ConversationProperty Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_template_idx(int32_t template_idx) {
    fbb_.AddElement<int32_t>(ConversationProperty::VT_TEMPLATE_IDX, template_idx, 0);
  }
  void add_value_type(GameScript::PropertyValue value_type) {
    fbb_.AddElement<uint8_t>(ConversationProperty::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(ConversationProperty::VT_VALUE, value);
  }
  explicit ConversationPropertyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConversationProperty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConversationProperty>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ConversationProperty> CreateConversationProperty(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t template_idx = 0,
    GameScript::PropertyValue value_type = GameScript::PropertyValue_NONE,
    ::flatbuffers::Offset<void> value = 0) {
  ConversationPropertyBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_template_idx(template_idx);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CONVERSATION_IDX = 6,
    VT_TYPE = 8,
    VT_ACTOR_IDX = 10,
    VT_VOICE_TEXT = 12,
    VT_UI_RESPONSE_TEXT = 14,
    VT_HAS_CONDITION = 16,
    VT_HAS_ACTION = 18,
    VT_IS_PREVENT_RESPONSE = 20,
    VT_POSITION_X = 22,
    VT_POSITION_Y = 24,
    VT_NOTES = 26,
    VT_PROPERTIES = 28,
    VT_OUTGOING_EDGE_INDICES = 30,
    VT_INCOMING_EDGE_INDICES = 32
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t conversation_idx() const {
    return GetField<int32_t>(VT_CONVERSATION_IDX, 0);
  }
  GameScript::NodeType type() const {
    return static_cast<GameScript::NodeType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int32_t actor_idx() const {
    return GetField<int32_t>(VT_ACTOR_IDX, 0);
  }
  const ::flatbuffers::String *voice_text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VOICE_TEXT);
  }
  const ::flatbuffers::String *ui_response_text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UI_RESPONSE_TEXT);
  }
  bool has_condition() const {
    return GetField<uint8_t>(VT_HAS_CONDITION, 0) != 0;
  }
  bool has_action() const {
    return GetField<uint8_t>(VT_HAS_ACTION, 0) != 0;
  }
  bool is_prevent_response() const {
    return GetField<uint8_t>(VT_IS_PREVENT_RESPONSE, 0) != 0;
  }
  float position_x() const {
    return GetField<float>(VT_POSITION_X, 0.0f);
  }
  float position_y() const {
    return GetField<float>(VT_POSITION_Y, 0.0f);
  }
  const ::flatbuffers::String *notes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::NodeProperty>> *properties() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::NodeProperty>> *>(VT_PROPERTIES);
  }
  const ::flatbuffers::Vector<int32_t> *outgoing_edge_indices() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTGOING_EDGE_INDICES);
  }
  const ::flatbuffers::Vector<int32_t> *incoming_edge_indices() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INCOMING_EDGE_INDICES);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_CONVERSATION_IDX, 4) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_ACTOR_IDX, 4) &&
           VerifyOffset(verifier, VT_VOICE_TEXT) &&
           verifier.VerifyString(voice_text()) &&
           VerifyOffset(verifier, VT_UI_RESPONSE_TEXT) &&
           verifier.VerifyString(ui_response_text()) &&
           VerifyField<uint8_t>(verifier, VT_HAS_CONDITION, 1) &&
           VerifyField<uint8_t>(verifier, VT_HAS_ACTION, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_PREVENT_RESPONSE, 1) &&
           VerifyField<float>(verifier, VT_POSITION_X, 4) &&
           VerifyField<float>(verifier, VT_POSITION_Y, 4) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(notes()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_OUTGOING_EDGE_INDICES) &&
           verifier.VerifyVector(outgoing_edge_indices()) &&
           VerifyOffset(verifier, VT_INCOMING_EDGE_INDICES) &&
           verifier.VerifyVector(incoming_edge_indices()) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Node::VT_ID, id, 0);
  }
  void add_conversation_idx(int32_t conversation_idx) {
    fbb_.AddElement<int32_t>(Node::VT_CONVERSATION_IDX, conversation_idx, 0);
  }
  void add_type(GameScript::NodeType type) {
    fbb_.AddElement<int8_t>(Node::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_actor_idx(int32_t actor_idx) {
    fbb_.AddElement<int32_t>(Node::VT_ACTOR_IDX, actor_idx, 0);
  }
  void add_voice_text(::flatbuffers::Offset<::flatbuffers::String> voice_text) {
    fbb_.AddOffset(Node::VT_VOICE_TEXT, voice_text);
  }
  void add_ui_response_text(::flatbuffers::Offset<::flatbuffers::String> ui_response_text) {
    fbb_.AddOffset(Node::VT_UI_RESPONSE_TEXT, ui_response_text);
  }
  void add_has_condition(bool has_condition) {
    fbb_.AddElement<uint8_t>(Node::VT_HAS_CONDITION, static_cast<uint8_t>(has_condition), 0);
  }
  void add_has_action(bool has_action) {
    fbb_.AddElement<uint8_t>(Node::VT_HAS_ACTION, static_cast<uint8_t>(has_action), 0);
  }
  void add_is_prevent_response(bool is_prevent_response) {
    fbb_.AddElement<uint8_t>(Node::VT_IS_PREVENT_RESPONSE, static_cast<uint8_t>(is_prevent_response), 0);
  }
  void add_position_x(float position_x) {
    fbb_.AddElement<float>(Node::VT_POSITION_X, position_x, 0.0f);
  }
  void add_position_y(float position_y) {
    fbb_.AddElement<float>(Node::VT_POSITION_Y, position_y, 0.0f);
  }
  void add_notes(::flatbuffers::Offset<::flatbuffers::String> notes) {
    fbb_.AddOffset(Node::VT_NOTES, notes);
  }
  void add_properties(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::NodeProperty>>> properties) {
    fbb_.AddOffset(Node::VT_PROPERTIES, properties);
  }
  void add_outgoing_edge_indices(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outgoing_edge_indices) {
    fbb_.AddOffset(Node::VT_OUTGOING_EDGE_INDICES, outgoing_edge_indices);
  }
  void add_incoming_edge_indices(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> incoming_edge_indices) {
    fbb_.AddOffset(Node::VT_INCOMING_EDGE_INDICES, incoming_edge_indices);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t conversation_idx = 0,
    GameScript::NodeType type = GameScript::NodeType_Root,
    int32_t actor_idx = 0,
    ::flatbuffers::Offset<::flatbuffers::String> voice_text = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ui_response_text = 0,
    bool has_condition = false,
    bool has_action = false,
    bool is_prevent_response = false,
    float position_x = 0.0f,
    float position_y = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::String> notes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::NodeProperty>>> properties = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outgoing_edge_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> incoming_edge_indices = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_incoming_edge_indices(incoming_edge_indices);
  builder_.add_outgoing_edge_indices(outgoing_edge_indices);
  builder_.add_properties(properties);
  builder_.add_notes(notes);
  builder_.add_position_y(position_y);
  builder_.add_position_x(position_x);
  builder_.add_ui_response_text(ui_response_text);
  builder_.add_voice_text(voice_text);
  builder_.add_actor_idx(actor_idx);
  builder_.add_conversation_idx(conversation_idx);
  builder_.add_id(id);
  builder_.add_is_prevent_response(is_prevent_response);
  builder_.add_has_action(has_action);
  builder_.add_has_condition(has_condition);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t conversation_idx = 0,
    GameScript::NodeType type = GameScript::NodeType_Root,
    int32_t actor_idx = 0,
    const char *voice_text = nullptr,
    const char *ui_response_text = nullptr,
    bool has_condition = false,
    bool has_action = false,
    bool is_prevent_response = false,
    float position_x = 0.0f,
    float position_y = 0.0f,
    const char *notes = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::NodeProperty>> *properties = nullptr,
    const std::vector<int32_t> *outgoing_edge_indices = nullptr,
    const std::vector<int32_t> *incoming_edge_indices = nullptr) {
  auto voice_text__ = voice_text ? _fbb.CreateString(voice_text) : 0;
  auto ui_response_text__ = ui_response_text ? _fbb.CreateString(ui_response_text) : 0;
  auto notes__ = notes ? _fbb.CreateString(notes) : 0;
  auto properties__ = properties ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::NodeProperty>>(*properties) : 0;
  auto outgoing_edge_indices__ = outgoing_edge_indices ? _fbb.CreateVector<int32_t>(*outgoing_edge_indices) : 0;
  auto incoming_edge_indices__ = incoming_edge_indices ? _fbb.CreateVector<int32_t>(*incoming_edge_indices) : 0;
  return GameScript::CreateNode(
      _fbb,
      id,
      conversation_idx,
      type,
      actor_idx,
      voice_text__,
      ui_response_text__,
      has_condition,
      has_action,
      is_prevent_response,
      position_x,
      position_y,
      notes__,
      properties__,
      outgoing_edge_indices__,
      incoming_edge_indices__);
}

struct Edge FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EdgeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CONVERSATION_IDX = 6,
    VT_SOURCE_IDX = 8,
    VT_TARGET_IDX = 10,
    VT_PRIORITY = 12,
    VT_TYPE = 14
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t conversation_idx() const {
    return GetField<int32_t>(VT_CONVERSATION_IDX, 0);
  }
  int32_t source_idx() const {
    return GetField<int32_t>(VT_SOURCE_IDX, 0);
  }
  int32_t target_idx() const {
    return GetField<int32_t>(VT_TARGET_IDX, 0);
  }
  int32_t priority() const {
    return GetField<int32_t>(VT_PRIORITY, 0);
  }
  GameScript::EdgeType type() const {
    return static_cast<GameScript::EdgeType>(GetField<int8_t>(VT_TYPE, 0));
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_CONVERSATION_IDX, 4) &&
           VerifyField<int32_t>(verifier, VT_SOURCE_IDX, 4) &&
           VerifyField<int32_t>(verifier, VT_TARGET_IDX, 4) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct EdgeBuilder {
  typedef Edge Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Edge::VT_ID, id, 0);
  }
  void add_conversation_idx(int32_t conversation_idx) {
    fbb_.AddElement<int32_t>(Edge::VT_CONVERSATION_IDX, conversation_idx, 0);
  }
  void add_source_idx(int32_t source_idx) {
    fbb_.AddElement<int32_t>(Edge::VT_SOURCE_IDX, source_idx, 0);
  }
  void add_target_idx(int32_t target_idx) {
    fbb_.AddElement<int32_t>(Edge::VT_TARGET_IDX, target_idx, 0);
  }
  void add_priority(int32_t priority) {
    fbb_.AddElement<int32_t>(Edge::VT_PRIORITY, priority, 0);
  }
  void add_type(GameScript::EdgeType type) {
    fbb_.AddElement<int8_t>(Edge::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit EdgeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Edge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Edge>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Edge> CreateEdge(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t conversation_idx = 0,
    int32_t source_idx = 0,
    int32_t target_idx = 0,
    int32_t priority = 0,
    GameScript::EdgeType type = GameScript::EdgeType_Default) {
  EdgeBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_target_idx(target_idx);
  builder_.add_source_idx(source_idx);
  builder_.add_conversation_idx(conversation_idx);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Actor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_LOCALIZED_NAME = 8,
    VT_COLOR = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *localized_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCALIZED_NAME);
  }
  const ::flatbuffers::String *color() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLOR);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_LOCALIZED_NAME) &&
           verifier.VerifyString(localized_name()) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyString(color()) &&
           verifier.EndTable();
  }
};

struct ActorBuilder {
  typedef Actor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Actor::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Actor::VT_NAME, name);
  }
  void add_localized_name(::flatbuffers::Offset<::flatbuffers::String> localized_name) {
    fbb_.AddOffset(Actor::VT_LOCALIZED_NAME, localized_name);
  }
  void add_color(::flatbuffers::Offset<::flatbuffers::String> color) {
    fbb_.AddOffset(Actor::VT_COLOR, color);
  }
  explicit ActorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Actor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Actor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Actor> CreateActor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> localized_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> color = 0) {
  ActorBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_localized_name(localized_name);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Actor> CreateActorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    const char *localized_name = nullptr,
    const char *color = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto localized_name__ = localized_name ? _fbb.CreateString(localized_name) : 0;
  auto color__ = color ? _fbb.CreateString(color) : 0;
  return GameScript::CreateActor(
      _fbb,
      id,
      name__,
      localized_name__,
      color__);
}

struct Conversation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConversationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_NOTES = 8,
    VT_IS_LAYOUT_AUTO = 10,
    VT_IS_LAYOUT_VERTICAL = 12,
    VT_TAG_INDICES = 14,
    VT_PROPERTIES = 16,
    VT_NODE_INDICES = 18,
    VT_EDGE_INDICES = 20,
    VT_ROOT_NODE_IDX = 22
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *notes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  bool is_layout_auto() const {
    return GetField<uint8_t>(VT_IS_LAYOUT_AUTO, 0) != 0;
  }
  bool is_layout_vertical() const {
    return GetField<uint8_t>(VT_IS_LAYOUT_VERTICAL, 0) != 0;
  }
  const ::flatbuffers::Vector<int32_t> *tag_indices() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TAG_INDICES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::ConversationProperty>> *properties() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::ConversationProperty>> *>(VT_PROPERTIES);
  }
  const ::flatbuffers::Vector<int32_t> *node_indices() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_NODE_INDICES);
  }
  const ::flatbuffers::Vector<int32_t> *edge_indices() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_EDGE_INDICES);
  }
  int32_t root_node_idx() const {
    return GetField<int32_t>(VT_ROOT_NODE_IDX, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(notes()) &&
           VerifyField<uint8_t>(verifier, VT_IS_LAYOUT_AUTO, 1) &&
           VerifyField<uint8_t>(verifier, VT_IS_LAYOUT_VERTICAL, 1) &&
           VerifyOffset(verifier, VT_TAG_INDICES) &&
           verifier.VerifyVector(tag_indices()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_NODE_INDICES) &&
           verifier.VerifyVector(node_indices()) &&
           VerifyOffset(verifier, VT_EDGE_INDICES) &&
           verifier.VerifyVector(edge_indices()) &&
           VerifyField<int32_t>(verifier, VT_ROOT_NODE_IDX, 4) &&
           verifier.EndTable();
  }
};

struct ConversationBuilder {
  typedef Conversation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Conversation::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Conversation::VT_NAME, name);
  }
  void add_notes(::flatbuffers::Offset<::flatbuffers::String> notes) {
    fbb_.AddOffset(Conversation::VT_NOTES, notes);
  }
  void add_is_layout_auto(bool is_layout_auto) {
    fbb_.AddElement<uint8_t>(Conversation::VT_IS_LAYOUT_AUTO, static_cast<uint8_t>(is_layout_auto), 0);
  }
  void add_is_layout_vertical(bool is_layout_vertical) {
    fbb_.AddElement<uint8_t>(Conversation::VT_IS_LAYOUT_VERTICAL, static_cast<uint8_t>(is_layout_vertical), 0);
  }
  void add_tag_indices(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> tag_indices) {
    fbb_.AddOffset(Conversation::VT_TAG_INDICES, tag_indices);
  }
  void add_properties(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::ConversationProperty>>> properties) {
    fbb_.AddOffset(Conversation::VT_PROPERTIES, properties);
  }
  void add_node_indices(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> node_indices) {
    fbb_.AddOffset(Conversation::VT_NODE_INDICES, node_indices);
  }
  void add_edge_indices(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> edge_indices) {
    fbb_.AddOffset(Conversation::VT_EDGE_INDICES, edge_indices);
  }
  void add_root_node_idx(int32_t root_node_idx) {
    fbb_.AddElement<int32_t>(Conversation::VT_ROOT_NODE_IDX, root_node_idx, 0);
  }
  explicit ConversationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conversation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conversation>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conversation> CreateConversation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> notes = 0,
    bool is_layout_auto = false,
    bool is_layout_vertical = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> tag_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::ConversationProperty>>> properties = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> node_indices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> edge_indices = 0,
    int32_t root_node_idx = 0) {
  ConversationBuilder builder_(_fbb);
  builder_.add_root_node_idx(root_node_idx);
  builder_.add_edge_indices(edge_indices);
  builder_.add_node_indices(node_indices);
  builder_.add_properties(properties);
  builder_.add_tag_indices(tag_indices);
  builder_.add_notes(notes);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_is_layout_vertical(is_layout_vertical);
  builder_.add_is_layout_auto(is_layout_auto);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Conversation> CreateConversationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    const char *notes = nullptr,
    bool is_layout_auto = false,
    bool is_layout_vertical = false,
    const std::vector<int32_t> *tag_indices = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::ConversationProperty>> *properties = nullptr,
    const std::vector<int32_t> *node_indices = nullptr,
    const std::vector<int32_t> *edge_indices = nullptr,
    int32_t root_node_idx = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto notes__ = notes ? _fbb.CreateString(notes) : 0;
  auto tag_indices__ = tag_indices ? _fbb.CreateVector<int32_t>(*tag_indices) : 0;
  auto properties__ = properties ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::ConversationProperty>>(*properties) : 0;
  auto node_indices__ = node_indices ? _fbb.CreateVector<int32_t>(*node_indices) : 0;
  auto edge_indices__ = edge_indices ? _fbb.CreateVector<int32_t>(*edge_indices) : 0;
  return GameScript::CreateConversation(
      _fbb,
      id,
      name__,
      notes__,
      is_layout_auto,
      is_layout_vertical,
      tag_indices__,
      properties__,
      node_indices__,
      edge_indices__,
      root_node_idx);
}

struct Localization FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LocalizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TEXT = 8,
    VT_TAG_INDICES = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const ::flatbuffers::Vector<int32_t> *tag_indices() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TAG_INDICES);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffset(verifier, VT_TAG_INDICES) &&
           verifier.VerifyVector(tag_indices()) &&
           verifier.EndTable();
  }
};

struct LocalizationBuilder {
  typedef Localization Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(Localization::VT_ID, id, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Localization::VT_NAME, name);
  }
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(Localization::VT_TEXT, text);
  }
  void add_tag_indices(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> tag_indices) {
    fbb_.AddOffset(Localization::VT_TAG_INDICES, tag_indices);
  }
  explicit LocalizationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Localization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Localization>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Localization> CreateLocalization(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> tag_indices = 0) {
  LocalizationBuilder builder_(_fbb);
  builder_.add_tag_indices(tag_indices);
  builder_.add_text(text);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Localization> CreateLocalizationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    const char *name = nullptr,
    const char *text = nullptr,
    const std::vector<int32_t> *tag_indices = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto tag_indices__ = tag_indices ? _fbb.CreateVector<int32_t>(*tag_indices) : 0;
  return GameScript::CreateLocalization(
      _fbb,
      id,
      name__,
      text__,
      tag_indices__);
}

struct Snapshot FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SnapshotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCALE_ID = 4,
    VT_LOCALE_NAME = 6,
    VT_CONVERSATION_TAG_NAMES = 8,
    VT_CONVERSATION_TAG_VALUES = 10,
    VT_CONVERSATIONS = 12,
    VT_NODES = 14,
    VT_EDGES = 16,
    VT_ACTORS = 18,
    VT_LOCALIZATION_TAG_NAMES = 20,
    VT_LOCALIZATION_TAG_VALUES = 22,
    VT_LOCALIZATIONS = 24,
    VT_PROPERTY_TEMPLATES = 26
  };
  int32_t locale_id() const {
    return GetField<int32_t>(VT_LOCALE_ID, 0);
  }
  const ::flatbuffers::String *locale_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCALE_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *conversation_tag_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CONVERSATION_TAG_NAMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::StringArray>> *conversation_tag_values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::StringArray>> *>(VT_CONVERSATION_TAG_VALUES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Conversation>> *conversations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Conversation>> *>(VT_CONVERSATIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Node>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Node>> *>(VT_NODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Edge>> *edges() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Edge>> *>(VT_EDGES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Actor>> *actors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Actor>> *>(VT_ACTORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *localization_tag_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LOCALIZATION_TAG_NAMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::StringArray>> *localization_tag_values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::StringArray>> *>(VT_LOCALIZATION_TAG_VALUES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Localization>> *localizations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Localization>> *>(VT_LOCALIZATIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::PropertyTemplate>> *property_templates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<GameScript::PropertyTemplate>> *>(VT_PROPERTY_TEMPLATES);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LOCALE_ID, 4) &&
           VerifyOffset(verifier, VT_LOCALE_NAME) &&
           verifier.VerifyString(locale_name()) &&
           VerifyOffset(verifier, VT_CONVERSATION_TAG_NAMES) &&
           verifier.VerifyVector(conversation_tag_names()) &&
           verifier.VerifyVectorOfStrings(conversation_tag_names()) &&
           VerifyOffset(verifier, VT_CONVERSATION_TAG_VALUES) &&
           verifier.VerifyVector(conversation_tag_values()) &&
           verifier.VerifyVectorOfTables(conversation_tag_values()) &&
           VerifyOffset(verifier, VT_CONVERSATIONS) &&
           verifier.VerifyVector(conversations()) &&
           verifier.VerifyVectorOfTables(conversations()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_EDGES) &&
           verifier.VerifyVector(edges()) &&
           verifier.VerifyVectorOfTables(edges()) &&
           VerifyOffset(verifier, VT_ACTORS) &&
           verifier.VerifyVector(actors()) &&
           verifier.VerifyVectorOfTables(actors()) &&
           VerifyOffset(verifier, VT_LOCALIZATION_TAG_NAMES) &&
           verifier.VerifyVector(localization_tag_names()) &&
           verifier.VerifyVectorOfStrings(localization_tag_names()) &&
           VerifyOffset(verifier, VT_LOCALIZATION_TAG_VALUES) &&
           verifier.VerifyVector(localization_tag_values()) &&
           verifier.VerifyVectorOfTables(localization_tag_values()) &&
           VerifyOffset(verifier, VT_LOCALIZATIONS) &&
           verifier.VerifyVector(localizations()) &&
           verifier.VerifyVectorOfTables(localizations()) &&
           VerifyOffset(verifier, VT_PROPERTY_TEMPLATES) &&
           verifier.VerifyVector(property_templates()) &&
           verifier.VerifyVectorOfTables(property_templates()) &&
           verifier.EndTable();
  }
};

struct SnapshotBuilder {
  typedef Snapshot Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_locale_id(int32_t locale_id) {
    fbb_.AddElement<int32_t>(Snapshot::VT_LOCALE_ID, locale_id, 0);
  }
  void add_locale_name(::flatbuffers::Offset<::flatbuffers::String> locale_name) {
    fbb_.AddOffset(Snapshot::VT_LOCALE_NAME, locale_name);
  }
  void add_conversation_tag_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> conversation_tag_names) {
    fbb_.AddOffset(Snapshot::VT_CONVERSATION_TAG_NAMES, conversation_tag_names);
  }
  void add_conversation_tag_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::StringArray>>> conversation_tag_values) {
    fbb_.AddOffset(Snapshot::VT_CONVERSATION_TAG_VALUES, conversation_tag_values);
  }
  void add_conversations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Conversation>>> conversations) {
    fbb_.AddOffset(Snapshot::VT_CONVERSATIONS, conversations);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Node>>> nodes) {
    fbb_.AddOffset(Snapshot::VT_NODES, nodes);
  }
  void add_edges(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Edge>>> edges) {
    fbb_.AddOffset(Snapshot::VT_EDGES, edges);
  }
  void add_actors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Actor>>> actors) {
    fbb_.AddOffset(Snapshot::VT_ACTORS, actors);
  }
  void add_localization_tag_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> localization_tag_names) {
    fbb_.AddOffset(Snapshot::VT_LOCALIZATION_TAG_NAMES, localization_tag_names);
  }
  void add_localization_tag_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::StringArray>>> localization_tag_values) {
    fbb_.AddOffset(Snapshot::VT_LOCALIZATION_TAG_VALUES, localization_tag_values);
  }
  void add_localizations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Localization>>> localizations) {
    fbb_.AddOffset(Snapshot::VT_LOCALIZATIONS, localizations);
  }
  void add_property_templates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::PropertyTemplate>>> property_templates) {
    fbb_.AddOffset(Snapshot::VT_PROPERTY_TEMPLATES, property_templates);
  }
  explicit SnapshotBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Snapshot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Snapshot>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Snapshot> CreateSnapshot(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t locale_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> locale_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> conversation_tag_names = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::StringArray>>> conversation_tag_values = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Conversation>>> conversations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Node>>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Edge>>> edges = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Actor>>> actors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> localization_tag_names = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::StringArray>>> localization_tag_values = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::Localization>>> localizations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<GameScript::PropertyTemplate>>> property_templates = 0) {
  SnapshotBuilder builder_(_fbb);
  builder_.add_property_templates(property_templates);
  builder_.add_localizations(localizations);
  builder_.add_localization_tag_values(localization_tag_values);
  builder_.add_localization_tag_names(localization_tag_names);
  builder_.add_actors(actors);
  builder_.add_edges(edges);
  builder_.add_nodes(nodes);
  builder_.add_conversations(conversations);
  builder_.add_conversation_tag_values(conversation_tag_values);
  builder_.add_conversation_tag_names(conversation_tag_names);
  builder_.add_locale_name(locale_name);
  builder_.add_locale_id(locale_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Snapshot> CreateSnapshotDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t locale_id = 0,
    const char *locale_name = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *conversation_tag_names = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::StringArray>> *conversation_tag_values = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::Conversation>> *conversations = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::Node>> *nodes = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::Edge>> *edges = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::Actor>> *actors = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *localization_tag_names = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::StringArray>> *localization_tag_values = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::Localization>> *localizations = nullptr,
    const std::vector<::flatbuffers::Offset<GameScript::PropertyTemplate>> *property_templates = nullptr) {
  auto locale_name__ = locale_name ? _fbb.CreateString(locale_name) : 0;
  auto conversation_tag_names__ = conversation_tag_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*conversation_tag_names) : 0;
  auto conversation_tag_values__ = conversation_tag_values ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::StringArray>>(*conversation_tag_values) : 0;
  auto conversations__ = conversations ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::Conversation>>(*conversations) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::Node>>(*nodes) : 0;
  auto edges__ = edges ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::Edge>>(*edges) : 0;
  auto actors__ = actors ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::Actor>>(*actors) : 0;
  auto localization_tag_names__ = localization_tag_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*localization_tag_names) : 0;
  auto localization_tag_values__ = localization_tag_values ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::StringArray>>(*localization_tag_values) : 0;
  auto localizations__ = localizations ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::Localization>>(*localizations) : 0;
  auto property_templates__ = property_templates ? _fbb.CreateVector<::flatbuffers::Offset<GameScript::PropertyTemplate>>(*property_templates) : 0;
  return GameScript::CreateSnapshot(
      _fbb,
      locale_id,
      locale_name__,
      conversation_tag_names__,
      conversation_tag_values__,
      conversations__,
      nodes__,
      edges__,
      actors__,
      localization_tag_names__,
      localization_tag_values__,
      localizations__,
      property_templates__);
}

struct StringArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_VALUES);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.VerifyVectorOfStrings(values()) &&
           verifier.EndTable();
  }
};

struct StringArrayBuilder {
  typedef StringArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> values) {
    fbb_.AddOffset(StringArray::VT_VALUES, values);
  }
  explicit StringArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringArray> CreateStringArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> values = 0) {
  StringArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringArray> CreateStringArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*values) : 0;
  return GameScript::CreateStringArray(
      _fbb,
      values__);
}

template <bool B>
inline bool VerifyPropertyValue(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, PropertyValue type) {
  switch (type) {
    case PropertyValue_NONE: {
      return true;
    }
    case PropertyValue_string_val: {
      auto ptr = reinterpret_cast<const ::flatbuffers::String *>(obj);
      return verifier.VerifyString(ptr);
    }
    case PropertyValue_int_val: {
      auto ptr = reinterpret_cast<const GameScript::Int32Value *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PropertyValue_decimal_val: {
      auto ptr = reinterpret_cast<const GameScript::FloatValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PropertyValue_bool_val: {
      auto ptr = reinterpret_cast<const GameScript::BoolValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

template <bool B>
inline bool VerifyPropertyValueVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPropertyValue(
        verifier,  values->Get(i), types->GetEnum<PropertyValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const GameScript::Snapshot *GetSnapshot(const void *buf) {
  return ::flatbuffers::GetRoot<GameScript::Snapshot>(buf);
}

inline const GameScript::Snapshot *GetSizePrefixedSnapshot(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<GameScript::Snapshot>(buf);
}

inline const char *SnapshotIdentifier() {
  return "GSPT";
}

inline bool SnapshotBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SnapshotIdentifier());
}

inline bool SizePrefixedSnapshotBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SnapshotIdentifier(), true);
}

template <bool B = false>
inline bool VerifySnapshotBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<GameScript::Snapshot>(SnapshotIdentifier());
}

template <bool B = false>
inline bool VerifySizePrefixedSnapshotBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<GameScript::Snapshot>(SnapshotIdentifier());
}

inline const char *SnapshotExtension() {
  return "gsb";
}

inline void FinishSnapshotBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GameScript::Snapshot> root) {
  fbb.Finish(root, SnapshotIdentifier());
}

inline void FinishSizePrefixedSnapshotBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<GameScript::Snapshot> root) {
  fbb.FinishSizePrefixed(root, SnapshotIdentifier());
}

}  // namespace GameScript

#endif  // FLATBUFFERS_GENERATED_SNAPSHOT_GAMESCRIPT_H_
