// <auto-generated>
//  automatically generated by the FlatBuffers compiler, do not modify
// </auto-generated>

namespace GameScript
{

using global::System;
using global::System.Collections.Generic;
using global::Google.FlatBuffers;

public struct Node : IFlatbufferObject
{
  private Table __p;
  public ByteBuffer ByteBuffer { get { return __p.bb; } }
  public static void ValidateVersion() { FlatBufferConstants.FLATBUFFERS_25_12_19(); }
  public static Node GetRootAsNode(ByteBuffer _bb) { return GetRootAsNode(_bb, new Node()); }
  public static Node GetRootAsNode(ByteBuffer _bb, Node obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __p = new Table(_i, _bb); }
  public Node __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  public int Id { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public int ConversationIdx { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public GameScript.NodeType Type { get { int o = __p.__offset(8); return o != 0 ? (GameScript.NodeType)__p.bb.GetSbyte(o + __p.bb_pos) : GameScript.NodeType.Root; } }
  public int ActorIdx { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
  public string VoiceText { get { int o = __p.__offset(12); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetVoiceTextBytes() { return __p.__vector_as_span<byte>(12, 1); }
#else
  public ArraySegment<byte>? GetVoiceTextBytes() { return __p.__vector_as_arraysegment(12); }
#endif
  public byte[] GetVoiceTextArray() { return __p.__vector_as_array<byte>(12); }
  public string UiResponseText { get { int o = __p.__offset(14); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetUiResponseTextBytes() { return __p.__vector_as_span<byte>(14, 1); }
#else
  public ArraySegment<byte>? GetUiResponseTextBytes() { return __p.__vector_as_arraysegment(14); }
#endif
  public byte[] GetUiResponseTextArray() { return __p.__vector_as_array<byte>(14); }
  public bool HasCondition { get { int o = __p.__offset(16); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool HasAction { get { int o = __p.__offset(18); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public bool IsPreventResponse { get { int o = __p.__offset(20); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }
  public float PositionX { get { int o = __p.__offset(22); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public float PositionY { get { int o = __p.__offset(24); return o != 0 ? __p.bb.GetFloat(o + __p.bb_pos) : (float)0.0f; } }
  public string Notes { get { int o = __p.__offset(26); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }
#if ENABLE_SPAN_T
  public Span<byte> GetNotesBytes() { return __p.__vector_as_span<byte>(26, 1); }
#else
  public ArraySegment<byte>? GetNotesBytes() { return __p.__vector_as_arraysegment(26); }
#endif
  public byte[] GetNotesArray() { return __p.__vector_as_array<byte>(26); }
  public GameScript.NodeProperty? Properties(int j) { int o = __p.__offset(28); return o != 0 ? (GameScript.NodeProperty?)(new GameScript.NodeProperty()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
  public int PropertiesLength { get { int o = __p.__offset(28); return o != 0 ? __p.__vector_len(o) : 0; } }
  public int OutgoingEdgeIndices(int j) { int o = __p.__offset(30); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int OutgoingEdgeIndicesLength { get { int o = __p.__offset(30); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetOutgoingEdgeIndicesBytes() { return __p.__vector_as_span<int>(30, 4); }
#else
  public ArraySegment<byte>? GetOutgoingEdgeIndicesBytes() { return __p.__vector_as_arraysegment(30); }
#endif
  public int[] GetOutgoingEdgeIndicesArray() { return __p.__vector_as_array<int>(30); }
  public int IncomingEdgeIndices(int j) { int o = __p.__offset(32); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }
  public int IncomingEdgeIndicesLength { get { int o = __p.__offset(32); return o != 0 ? __p.__vector_len(o) : 0; } }
#if ENABLE_SPAN_T
  public Span<int> GetIncomingEdgeIndicesBytes() { return __p.__vector_as_span<int>(32, 4); }
#else
  public ArraySegment<byte>? GetIncomingEdgeIndicesBytes() { return __p.__vector_as_arraysegment(32); }
#endif
  public int[] GetIncomingEdgeIndicesArray() { return __p.__vector_as_array<int>(32); }

  public static Offset<GameScript.Node> CreateNode(FlatBufferBuilder builder,
      int id = 0,
      int conversation_idx = 0,
      GameScript.NodeType type = GameScript.NodeType.Root,
      int actor_idx = 0,
      StringOffset voice_textOffset = default(StringOffset),
      StringOffset ui_response_textOffset = default(StringOffset),
      bool has_condition = false,
      bool has_action = false,
      bool is_prevent_response = false,
      float position_x = 0.0f,
      float position_y = 0.0f,
      StringOffset notesOffset = default(StringOffset),
      VectorOffset propertiesOffset = default(VectorOffset),
      VectorOffset outgoing_edge_indicesOffset = default(VectorOffset),
      VectorOffset incoming_edge_indicesOffset = default(VectorOffset)) {
    builder.StartTable(15);
    Node.AddIncomingEdgeIndices(builder, incoming_edge_indicesOffset);
    Node.AddOutgoingEdgeIndices(builder, outgoing_edge_indicesOffset);
    Node.AddProperties(builder, propertiesOffset);
    Node.AddNotes(builder, notesOffset);
    Node.AddPositionY(builder, position_y);
    Node.AddPositionX(builder, position_x);
    Node.AddUiResponseText(builder, ui_response_textOffset);
    Node.AddVoiceText(builder, voice_textOffset);
    Node.AddActorIdx(builder, actor_idx);
    Node.AddConversationIdx(builder, conversation_idx);
    Node.AddId(builder, id);
    Node.AddIsPreventResponse(builder, is_prevent_response);
    Node.AddHasAction(builder, has_action);
    Node.AddHasCondition(builder, has_condition);
    Node.AddType(builder, type);
    return Node.EndNode(builder);
  }

  public static void StartNode(FlatBufferBuilder builder) { builder.StartTable(15); }
  public static void AddId(FlatBufferBuilder builder, int id) { builder.AddInt(0, id, 0); }
  public static void AddConversationIdx(FlatBufferBuilder builder, int conversationIdx) { builder.AddInt(1, conversationIdx, 0); }
  public static void AddType(FlatBufferBuilder builder, GameScript.NodeType type) { builder.AddSbyte(2, (sbyte)type, 0); }
  public static void AddActorIdx(FlatBufferBuilder builder, int actorIdx) { builder.AddInt(3, actorIdx, 0); }
  public static void AddVoiceText(FlatBufferBuilder builder, StringOffset voiceTextOffset) { builder.AddOffset(4, voiceTextOffset.Value, 0); }
  public static void AddUiResponseText(FlatBufferBuilder builder, StringOffset uiResponseTextOffset) { builder.AddOffset(5, uiResponseTextOffset.Value, 0); }
  public static void AddHasCondition(FlatBufferBuilder builder, bool hasCondition) { builder.AddBool(6, hasCondition, false); }
  public static void AddHasAction(FlatBufferBuilder builder, bool hasAction) { builder.AddBool(7, hasAction, false); }
  public static void AddIsPreventResponse(FlatBufferBuilder builder, bool isPreventResponse) { builder.AddBool(8, isPreventResponse, false); }
  public static void AddPositionX(FlatBufferBuilder builder, float positionX) { builder.AddFloat(9, positionX, 0.0f); }
  public static void AddPositionY(FlatBufferBuilder builder, float positionY) { builder.AddFloat(10, positionY, 0.0f); }
  public static void AddNotes(FlatBufferBuilder builder, StringOffset notesOffset) { builder.AddOffset(11, notesOffset.Value, 0); }
  public static void AddProperties(FlatBufferBuilder builder, VectorOffset propertiesOffset) { builder.AddOffset(12, propertiesOffset.Value, 0); }
  public static VectorOffset CreatePropertiesVector(FlatBufferBuilder builder, Offset<GameScript.NodeProperty>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
  public static VectorOffset CreatePropertiesVectorBlock(FlatBufferBuilder builder, Offset<GameScript.NodeProperty>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePropertiesVectorBlock(FlatBufferBuilder builder, ArraySegment<Offset<GameScript.NodeProperty>> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreatePropertiesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<Offset<GameScript.NodeProperty>>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartPropertiesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddOutgoingEdgeIndices(FlatBufferBuilder builder, VectorOffset outgoingEdgeIndicesOffset) { builder.AddOffset(13, outgoingEdgeIndicesOffset.Value, 0); }
  public static VectorOffset CreateOutgoingEdgeIndicesVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateOutgoingEdgeIndicesVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutgoingEdgeIndicesVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateOutgoingEdgeIndicesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartOutgoingEdgeIndicesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static void AddIncomingEdgeIndices(FlatBufferBuilder builder, VectorOffset incomingEdgeIndicesOffset) { builder.AddOffset(14, incomingEdgeIndicesOffset.Value, 0); }
  public static VectorOffset CreateIncomingEdgeIndicesVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }
  public static VectorOffset CreateIncomingEdgeIndicesVectorBlock(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateIncomingEdgeIndicesVectorBlock(FlatBufferBuilder builder, ArraySegment<int> data) { builder.StartVector(4, data.Count, 4); builder.Add(data); return builder.EndVector(); }
  public static VectorOffset CreateIncomingEdgeIndicesVectorBlock(FlatBufferBuilder builder, IntPtr dataPtr, int sizeInBytes) { builder.StartVector(1, sizeInBytes, 1); builder.Add<int>(dataPtr, sizeInBytes); return builder.EndVector(); }
  public static void StartIncomingEdgeIndicesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
  public static Offset<GameScript.Node> EndNode(FlatBufferBuilder builder) {
    int o = builder.EndTable();
    return new Offset<GameScript.Node>(o);
  }
  public NodeT UnPack() {
    var _o = new NodeT();
    this.UnPackTo(_o);
    return _o;
  }
  public void UnPackTo(NodeT _o) {
    _o.Id = this.Id;
    _o.ConversationIdx = this.ConversationIdx;
    _o.Type = this.Type;
    _o.ActorIdx = this.ActorIdx;
    _o.VoiceText = this.VoiceText;
    _o.UiResponseText = this.UiResponseText;
    _o.HasCondition = this.HasCondition;
    _o.HasAction = this.HasAction;
    _o.IsPreventResponse = this.IsPreventResponse;
    _o.PositionX = this.PositionX;
    _o.PositionY = this.PositionY;
    _o.Notes = this.Notes;
    _o.Properties = new List<GameScript.NodePropertyT>();
    for (var _j = 0; _j < this.PropertiesLength; ++_j) {_o.Properties.Add(this.Properties(_j).HasValue ? this.Properties(_j).Value.UnPack() : null);}
    _o.OutgoingEdgeIndices = new List<int>();
    for (var _j = 0; _j < this.OutgoingEdgeIndicesLength; ++_j) {_o.OutgoingEdgeIndices.Add(this.OutgoingEdgeIndices(_j));}
    _o.IncomingEdgeIndices = new List<int>();
    for (var _j = 0; _j < this.IncomingEdgeIndicesLength; ++_j) {_o.IncomingEdgeIndices.Add(this.IncomingEdgeIndices(_j));}
  }
  public static Offset<GameScript.Node> Pack(FlatBufferBuilder builder, NodeT _o) {
    if (_o == null) return default(Offset<GameScript.Node>);
    var _voice_text = _o.VoiceText == null ? default(StringOffset) : builder.CreateString(_o.VoiceText);
    var _ui_response_text = _o.UiResponseText == null ? default(StringOffset) : builder.CreateString(_o.UiResponseText);
    var _notes = _o.Notes == null ? default(StringOffset) : builder.CreateString(_o.Notes);
    var _properties = default(VectorOffset);
    if (_o.Properties != null) {
      var __properties = new Offset<GameScript.NodeProperty>[_o.Properties.Count];
      for (var _j = 0; _j < __properties.Length; ++_j) { __properties[_j] = GameScript.NodeProperty.Pack(builder, _o.Properties[_j]); }
      _properties = CreatePropertiesVector(builder, __properties);
    }
    var _outgoing_edge_indices = default(VectorOffset);
    if (_o.OutgoingEdgeIndices != null) {
      var __outgoing_edge_indices = _o.OutgoingEdgeIndices.ToArray();
      _outgoing_edge_indices = CreateOutgoingEdgeIndicesVector(builder, __outgoing_edge_indices);
    }
    var _incoming_edge_indices = default(VectorOffset);
    if (_o.IncomingEdgeIndices != null) {
      var __incoming_edge_indices = _o.IncomingEdgeIndices.ToArray();
      _incoming_edge_indices = CreateIncomingEdgeIndicesVector(builder, __incoming_edge_indices);
    }
    return CreateNode(
      builder,
      _o.Id,
      _o.ConversationIdx,
      _o.Type,
      _o.ActorIdx,
      _voice_text,
      _ui_response_text,
      _o.HasCondition,
      _o.HasAction,
      _o.IsPreventResponse,
      _o.PositionX,
      _o.PositionY,
      _notes,
      _properties,
      _outgoing_edge_indices,
      _incoming_edge_indices);
  }
}

public class NodeT
{
  public int Id { get; set; }
  public int ConversationIdx { get; set; }
  public GameScript.NodeType Type { get; set; }
  public int ActorIdx { get; set; }
  public string VoiceText { get; set; }
  public string UiResponseText { get; set; }
  public bool HasCondition { get; set; }
  public bool HasAction { get; set; }
  public bool IsPreventResponse { get; set; }
  public float PositionX { get; set; }
  public float PositionY { get; set; }
  public string Notes { get; set; }
  public List<GameScript.NodePropertyT> Properties { get; set; }
  public List<int> OutgoingEdgeIndices { get; set; }
  public List<int> IncomingEdgeIndices { get; set; }

  public NodeT() {
    this.Id = 0;
    this.ConversationIdx = 0;
    this.Type = GameScript.NodeType.Root;
    this.ActorIdx = 0;
    this.VoiceText = null;
    this.UiResponseText = null;
    this.HasCondition = false;
    this.HasAction = false;
    this.IsPreventResponse = false;
    this.PositionX = 0.0f;
    this.PositionY = 0.0f;
    this.Notes = null;
    this.Properties = null;
    this.OutgoingEdgeIndices = null;
    this.IncomingEdgeIndices = null;
  }
}


static public class NodeVerify
{
  static public bool Verify(Google.FlatBuffers.Verifier verifier, uint tablePos)
  {
    return verifier.VerifyTableStart(tablePos)
      && verifier.VerifyField(tablePos, 4 /*Id*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 6 /*ConversationIdx*/, 4 /*int*/, 4, false)
      && verifier.VerifyField(tablePos, 8 /*Type*/, 1 /*GameScript.NodeType*/, 1, false)
      && verifier.VerifyField(tablePos, 10 /*ActorIdx*/, 4 /*int*/, 4, false)
      && verifier.VerifyString(tablePos, 12 /*VoiceText*/, false)
      && verifier.VerifyString(tablePos, 14 /*UiResponseText*/, false)
      && verifier.VerifyField(tablePos, 16 /*HasCondition*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 18 /*HasAction*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 20 /*IsPreventResponse*/, 1 /*bool*/, 1, false)
      && verifier.VerifyField(tablePos, 22 /*PositionX*/, 4 /*float*/, 4, false)
      && verifier.VerifyField(tablePos, 24 /*PositionY*/, 4 /*float*/, 4, false)
      && verifier.VerifyString(tablePos, 26 /*Notes*/, false)
      && verifier.VerifyVectorOfTables(tablePos, 28 /*Properties*/, GameScript.NodePropertyVerify.Verify, false)
      && verifier.VerifyVectorOfData(tablePos, 30 /*OutgoingEdgeIndices*/, 4 /*int*/, false)
      && verifier.VerifyVectorOfData(tablePos, 32 /*IncomingEdgeIndices*/, 4 /*int*/, false)
      && verifier.VerifyTableEnd(tablePos);
  }
}

}
