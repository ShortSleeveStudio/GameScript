//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a RdGen v1.13.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Linq;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using JetBrains.Annotations;

using JetBrains.Core;
using JetBrains.Diagnostics;
using JetBrains.Collections;
using JetBrains.Collections.Viewable;
using JetBrains.Lifetimes;
using JetBrains.Serialization;
using JetBrains.Rd;
using JetBrains.Rd.Base;
using JetBrains.Rd.Impl;
using JetBrains.Rd.Tasks;
using JetBrains.Rd.Util;
using JetBrains.Rd.Text;


// ReSharper disable RedundantEmptyObjectCreationArgumentList
// ReSharper disable InconsistentNaming
// ReSharper disable RedundantOverflowCheckingContext


namespace GameScript.Backend.Protocol
{
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:65</p>
  /// </summary>
  public class GameScriptModel : RdExtBase
  {
    //fields
    //public fields
    [NotNull] public IRdEndpoint<Unit, int> GetProtocolVersion => _GetProtocolVersion;
    [NotNull] public IRdEndpoint<FindSymbolRequest, SymbolLocation> FindSymbol => _FindSymbol;
    [NotNull] public IRdEndpoint<DeleteSymbolRequest, DeleteSymbolResponse> DeleteSymbol => _DeleteSymbol;
    [NotNull] public IRdEndpoint<DeleteSymbolsRequest, DeleteSymbolsResponse> DeleteSymbols => _DeleteSymbols;
    [NotNull] public IRdEndpoint<CreateSymbolRequest, CreateSymbolResponse> CreateSymbol => _CreateSymbol;
    
    //private fields
    [NotNull] private readonly RdCall<Unit, int> _GetProtocolVersion;
    [NotNull] private readonly RdCall<FindSymbolRequest, SymbolLocation> _FindSymbol;
    [NotNull] private readonly RdCall<DeleteSymbolRequest, DeleteSymbolResponse> _DeleteSymbol;
    [NotNull] private readonly RdCall<DeleteSymbolsRequest, DeleteSymbolsResponse> _DeleteSymbols;
    [NotNull] private readonly RdCall<CreateSymbolRequest, CreateSymbolResponse> _CreateSymbol;
    
    //primary constructor
    private GameScriptModel(
      [NotNull] RdCall<Unit, int> getProtocolVersion,
      [NotNull] RdCall<FindSymbolRequest, SymbolLocation> findSymbol,
      [NotNull] RdCall<DeleteSymbolRequest, DeleteSymbolResponse> deleteSymbol,
      [NotNull] RdCall<DeleteSymbolsRequest, DeleteSymbolsResponse> deleteSymbols,
      [NotNull] RdCall<CreateSymbolRequest, CreateSymbolResponse> createSymbol
    )
    {
      if (getProtocolVersion == null) throw new ArgumentNullException("getProtocolVersion");
      if (findSymbol == null) throw new ArgumentNullException("findSymbol");
      if (deleteSymbol == null) throw new ArgumentNullException("deleteSymbol");
      if (deleteSymbols == null) throw new ArgumentNullException("deleteSymbols");
      if (createSymbol == null) throw new ArgumentNullException("createSymbol");
      
      _GetProtocolVersion = getProtocolVersion;
      _FindSymbol = findSymbol;
      _DeleteSymbol = deleteSymbol;
      _DeleteSymbols = deleteSymbols;
      _CreateSymbol = createSymbol;
      _FindSymbol.ValueCanBeNull = true;
      BindableChildren.Add(new KeyValuePair<string, object>("getProtocolVersion", _GetProtocolVersion));
      BindableChildren.Add(new KeyValuePair<string, object>("findSymbol", _FindSymbol));
      BindableChildren.Add(new KeyValuePair<string, object>("deleteSymbol", _DeleteSymbol));
      BindableChildren.Add(new KeyValuePair<string, object>("deleteSymbols", _DeleteSymbols));
      BindableChildren.Add(new KeyValuePair<string, object>("createSymbol", _CreateSymbol));
    }
    //secondary constructor
    private GameScriptModel (
    ) : this (
      new RdCall<Unit, int>(JetBrains.Rd.Impl.Serializers.ReadVoid, JetBrains.Rd.Impl.Serializers.WriteVoid, JetBrains.Rd.Impl.Serializers.ReadInt, JetBrains.Rd.Impl.Serializers.WriteInt),
      new RdCall<FindSymbolRequest, SymbolLocation>(FindSymbolRequest.Read, FindSymbolRequest.Write, ReadSymbolLocationNullable, WriteSymbolLocationNullable),
      new RdCall<DeleteSymbolRequest, DeleteSymbolResponse>(DeleteSymbolRequest.Read, DeleteSymbolRequest.Write, DeleteSymbolResponse.Read, DeleteSymbolResponse.Write),
      new RdCall<DeleteSymbolsRequest, DeleteSymbolsResponse>(DeleteSymbolsRequest.Read, DeleteSymbolsRequest.Write, DeleteSymbolsResponse.Read, DeleteSymbolsResponse.Write),
      new RdCall<CreateSymbolRequest, CreateSymbolResponse>(CreateSymbolRequest.Read, CreateSymbolRequest.Write, CreateSymbolResponse.Read, CreateSymbolResponse.Write)
    ) {}
    //deconstruct trait
    //statics
    
    public static CtxReadDelegate<SymbolLocation> ReadSymbolLocationNullable = SymbolLocation.Read.NullableClass();
    
    public static  CtxWriteDelegate<SymbolLocation> WriteSymbolLocationNullable = SymbolLocation.Write.NullableClass();
    
    protected override long SerializationHash => 1797009721247746664L;
    
    protected override Action<ISerializers> Register => RegisterDeclaredTypesSerializers;
    public static void RegisterDeclaredTypesSerializers(ISerializers serializers)
    {
      
      serializers.RegisterToplevelOnce(typeof(GameScriptModel), GameScriptModel.RegisterDeclaredTypesSerializers);
    }
    
    public GameScriptModel(Lifetime lifetime, IProtocol protocol) : this()
    {
      Identify(protocol.Identities, RdId.Root.Mix("GameScriptModel"));
      this.BindTopLevel(lifetime, protocol, "GameScriptModel");
    }
    
    //constants
    
    //custom body
    //methods
    //equals trait
    //hash code trait
    //pretty print
    public override void Print(PrettyPrinter printer)
    {
      printer.Println("GameScriptModel (");
      using (printer.IndentCookie()) {
        printer.Print("getProtocolVersion = "); _GetProtocolVersion.PrintEx(printer); printer.Println();
        printer.Print("findSymbol = "); _FindSymbol.PrintEx(printer); printer.Println();
        printer.Print("deleteSymbol = "); _DeleteSymbol.PrintEx(printer); printer.Println();
        printer.Print("deleteSymbols = "); _DeleteSymbols.PrintEx(printer); printer.Println();
        printer.Print("createSymbol = "); _CreateSymbol.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:192</p>
  /// </summary>
  public sealed class CreateSymbolRequest : IPrintable, IEquatable<CreateSymbolRequest>
  {
    //fields
    //public fields
    [NotNull] public string MethodStub {get; private set;}
    [NotNull] public string FilePath {get; private set;}
    [NotNull] public string FileContent {get; private set;}
    public bool UsesClassWrapper {get; private set;}
    
    //private fields
    //primary constructor
    public CreateSymbolRequest(
      [NotNull] string methodStub,
      [NotNull] string filePath,
      [NotNull] string fileContent,
      bool usesClassWrapper
    )
    {
      if (methodStub == null) throw new ArgumentNullException("methodStub");
      if (filePath == null) throw new ArgumentNullException("filePath");
      if (fileContent == null) throw new ArgumentNullException("fileContent");
      
      MethodStub = methodStub;
      FilePath = filePath;
      FileContent = fileContent;
      UsesClassWrapper = usesClassWrapper;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string methodStub, [NotNull] out string filePath, [NotNull] out string fileContent, out bool usesClassWrapper)
    {
      methodStub = MethodStub;
      filePath = FilePath;
      fileContent = FileContent;
      usesClassWrapper = UsesClassWrapper;
    }
    //statics
    
    public static CtxReadDelegate<CreateSymbolRequest> Read = (ctx, reader) => 
    {
      var methodStub = reader.ReadString();
      var filePath = reader.ReadString();
      var fileContent = reader.ReadString();
      var usesClassWrapper = reader.ReadBool();
      var _result = new CreateSymbolRequest(methodStub, filePath, fileContent, usesClassWrapper);
      return _result;
    };
    
    public static CtxWriteDelegate<CreateSymbolRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.MethodStub);
      writer.Write(value.FilePath);
      writer.Write(value.FileContent);
      writer.Write(value.UsesClassWrapper);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CreateSymbolRequest) obj);
    }
    public bool Equals(CreateSymbolRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return MethodStub == other.MethodStub && FilePath == other.FilePath && FileContent == other.FileContent && UsesClassWrapper == other.UsesClassWrapper;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + MethodStub.GetHashCode();
        hash = hash * 31 + FilePath.GetHashCode();
        hash = hash * 31 + FileContent.GetHashCode();
        hash = hash * 31 + UsesClassWrapper.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CreateSymbolRequest (");
      using (printer.IndentCookie()) {
        printer.Print("methodStub = "); MethodStub.PrintEx(printer); printer.Println();
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
        printer.Print("fileContent = "); FileContent.PrintEx(printer); printer.Println();
        printer.Print("usesClassWrapper = "); UsesClassWrapper.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:206</p>
  /// </summary>
  public sealed class CreateSymbolResponse : IPrintable, IEquatable<CreateSymbolResponse>
  {
    //fields
    //public fields
    public bool Success {get; private set;}
    public int LineNumber {get; private set;}
    [NotNull] public string Error {get; private set;}
    
    //private fields
    //primary constructor
    public CreateSymbolResponse(
      bool success,
      int lineNumber,
      [NotNull] string error
    )
    {
      if (error == null) throw new ArgumentNullException("error");
      
      Success = success;
      LineNumber = lineNumber;
      Error = error;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out bool success, out int lineNumber, [NotNull] out string error)
    {
      success = Success;
      lineNumber = LineNumber;
      error = Error;
    }
    //statics
    
    public static CtxReadDelegate<CreateSymbolResponse> Read = (ctx, reader) => 
    {
      var success = reader.ReadBool();
      var lineNumber = reader.ReadInt();
      var error = reader.ReadString();
      var _result = new CreateSymbolResponse(success, lineNumber, error);
      return _result;
    };
    
    public static CtxWriteDelegate<CreateSymbolResponse> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Success);
      writer.Write(value.LineNumber);
      writer.Write(value.Error);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((CreateSymbolResponse) obj);
    }
    public bool Equals(CreateSymbolResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Success == other.Success && LineNumber == other.LineNumber && Error == other.Error;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Success.GetHashCode();
        hash = hash * 31 + LineNumber.GetHashCode();
        hash = hash * 31 + Error.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("CreateSymbolResponse (");
      using (printer.IndentCookie()) {
        printer.Print("success = "); Success.PrintEx(printer); printer.Println();
        printer.Print("lineNumber = "); LineNumber.PrintEx(printer); printer.Println();
        printer.Print("error = "); Error.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:119</p>
  /// </summary>
  public sealed class DeleteSymbolRequest : IPrintable, IEquatable<DeleteSymbolRequest>
  {
    //fields
    //public fields
    [NotNull] public string SymbolName {get; private set;}
    [NotNull] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public DeleteSymbolRequest(
      [NotNull] string symbolName,
      [NotNull] string filePath
    )
    {
      if (symbolName == null) throw new ArgumentNullException("symbolName");
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      SymbolName = symbolName;
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string symbolName, [NotNull] out string filePath)
    {
      symbolName = SymbolName;
      filePath = FilePath;
    }
    //statics
    
    public static CtxReadDelegate<DeleteSymbolRequest> Read = (ctx, reader) => 
    {
      var symbolName = reader.ReadString();
      var filePath = reader.ReadString();
      var _result = new DeleteSymbolRequest(symbolName, filePath);
      return _result;
    };
    
    public static CtxWriteDelegate<DeleteSymbolRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.SymbolName);
      writer.Write(value.FilePath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((DeleteSymbolRequest) obj);
    }
    public bool Equals(DeleteSymbolRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return SymbolName == other.SymbolName && FilePath == other.FilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + SymbolName.GetHashCode();
        hash = hash * 31 + FilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("DeleteSymbolRequest (");
      using (printer.IndentCookie()) {
        printer.Print("symbolName = "); SymbolName.PrintEx(printer); printer.Println();
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:132</p>
  /// </summary>
  public sealed class DeleteSymbolResponse : IPrintable, IEquatable<DeleteSymbolResponse>
  {
    //fields
    //public fields
    public bool Success {get; private set;}
    public bool Found {get; private set;}
    [NotNull] public string DeletedText {get; private set;}
    [NotNull] public string Error {get; private set;}
    
    //private fields
    //primary constructor
    public DeleteSymbolResponse(
      bool success,
      bool found,
      [NotNull] string deletedText,
      [NotNull] string error
    )
    {
      if (deletedText == null) throw new ArgumentNullException("deletedText");
      if (error == null) throw new ArgumentNullException("error");
      
      Success = success;
      Found = found;
      DeletedText = deletedText;
      Error = error;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out bool success, out bool found, [NotNull] out string deletedText, [NotNull] out string error)
    {
      success = Success;
      found = Found;
      deletedText = DeletedText;
      error = Error;
    }
    //statics
    
    public static CtxReadDelegate<DeleteSymbolResponse> Read = (ctx, reader) => 
    {
      var success = reader.ReadBool();
      var found = reader.ReadBool();
      var deletedText = reader.ReadString();
      var error = reader.ReadString();
      var _result = new DeleteSymbolResponse(success, found, deletedText, error);
      return _result;
    };
    
    public static CtxWriteDelegate<DeleteSymbolResponse> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Success);
      writer.Write(value.Found);
      writer.Write(value.DeletedText);
      writer.Write(value.Error);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((DeleteSymbolResponse) obj);
    }
    public bool Equals(DeleteSymbolResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Success == other.Success && Found == other.Found && DeletedText == other.DeletedText && Error == other.Error;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Success.GetHashCode();
        hash = hash * 31 + Found.GetHashCode();
        hash = hash * 31 + DeletedText.GetHashCode();
        hash = hash * 31 + Error.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("DeleteSymbolResponse (");
      using (printer.IndentCookie()) {
        printer.Print("success = "); Success.PrintEx(printer); printer.Println();
        printer.Print("found = "); Found.PrintEx(printer); printer.Println();
        printer.Print("deletedText = "); DeletedText.PrintEx(printer); printer.Println();
        printer.Print("error = "); Error.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:149</p>
  /// </summary>
  public sealed class DeleteSymbolsRequest : IPrintable, IEquatable<DeleteSymbolsRequest>
  {
    //fields
    //public fields
    [NotNull] public List<string> SymbolNames {get; private set;}
    [NotNull] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public DeleteSymbolsRequest(
      [NotNull] List<string> symbolNames,
      [NotNull] string filePath
    )
    {
      if (symbolNames == null) throw new ArgumentNullException("symbolNames");
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      SymbolNames = symbolNames;
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out List<string> symbolNames, [NotNull] out string filePath)
    {
      symbolNames = SymbolNames;
      filePath = FilePath;
    }
    //statics
    
    public static CtxReadDelegate<DeleteSymbolsRequest> Read = (ctx, reader) => 
    {
      var symbolNames = ReadStringList(ctx, reader);
      var filePath = reader.ReadString();
      var _result = new DeleteSymbolsRequest(symbolNames, filePath);
      return _result;
    };
    public static CtxReadDelegate<List<string>> ReadStringList = JetBrains.Rd.Impl.Serializers.ReadString.List();
    
    public static CtxWriteDelegate<DeleteSymbolsRequest> Write = (ctx, writer, value) => 
    {
      WriteStringList(ctx, writer, value.SymbolNames);
      writer.Write(value.FilePath);
    };
    public static  CtxWriteDelegate<List<string>> WriteStringList = JetBrains.Rd.Impl.Serializers.WriteString.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((DeleteSymbolsRequest) obj);
    }
    public bool Equals(DeleteSymbolsRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return SymbolNames.SequenceEqual(other.SymbolNames) && FilePath == other.FilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + SymbolNames.ContentHashCode();
        hash = hash * 31 + FilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("DeleteSymbolsRequest (");
      using (printer.IndentCookie()) {
        printer.Print("symbolNames = "); SymbolNames.PrintEx(printer); printer.Println();
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:174</p>
  /// </summary>
  public sealed class DeleteSymbolsResponse : IPrintable, IEquatable<DeleteSymbolsResponse>
  {
    //fields
    //public fields
    public bool Success {get; private set;}
    [NotNull] public List<DeletedSymbolEntry> DeletedSymbols {get; private set;}
    [NotNull] public string Error {get; private set;}
    
    //private fields
    //primary constructor
    public DeleteSymbolsResponse(
      bool success,
      [NotNull] List<DeletedSymbolEntry> deletedSymbols,
      [NotNull] string error
    )
    {
      if (deletedSymbols == null) throw new ArgumentNullException("deletedSymbols");
      if (error == null) throw new ArgumentNullException("error");
      
      Success = success;
      DeletedSymbols = deletedSymbols;
      Error = error;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct(out bool success, [NotNull] out List<DeletedSymbolEntry> deletedSymbols, [NotNull] out string error)
    {
      success = Success;
      deletedSymbols = DeletedSymbols;
      error = Error;
    }
    //statics
    
    public static CtxReadDelegate<DeleteSymbolsResponse> Read = (ctx, reader) => 
    {
      var success = reader.ReadBool();
      var deletedSymbols = ReadDeletedSymbolEntryList(ctx, reader);
      var error = reader.ReadString();
      var _result = new DeleteSymbolsResponse(success, deletedSymbols, error);
      return _result;
    };
    public static CtxReadDelegate<List<DeletedSymbolEntry>> ReadDeletedSymbolEntryList = DeletedSymbolEntry.Read.List();
    
    public static CtxWriteDelegate<DeleteSymbolsResponse> Write = (ctx, writer, value) => 
    {
      writer.Write(value.Success);
      WriteDeletedSymbolEntryList(ctx, writer, value.DeletedSymbols);
      writer.Write(value.Error);
    };
    public static  CtxWriteDelegate<List<DeletedSymbolEntry>> WriteDeletedSymbolEntryList = DeletedSymbolEntry.Write.List();
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((DeleteSymbolsResponse) obj);
    }
    public bool Equals(DeleteSymbolsResponse other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return Success == other.Success && DeletedSymbols.SequenceEqual(other.DeletedSymbols) && Error == other.Error;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + Success.GetHashCode();
        hash = hash * 31 + DeletedSymbols.ContentHashCode();
        hash = hash * 31 + Error.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("DeleteSymbolsResponse (");
      using (printer.IndentCookie()) {
        printer.Print("success = "); Success.PrintEx(printer); printer.Println();
        printer.Print("deletedSymbols = "); DeletedSymbols.PrintEx(printer); printer.Println();
        printer.Print("error = "); Error.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:161</p>
  /// </summary>
  public sealed class DeletedSymbolEntry : IPrintable, IEquatable<DeletedSymbolEntry>
  {
    //fields
    //public fields
    [NotNull] public string SymbolName {get; private set;}
    public bool Found {get; private set;}
    [NotNull] public string DeletedText {get; private set;}
    
    //private fields
    //primary constructor
    public DeletedSymbolEntry(
      [NotNull] string symbolName,
      bool found,
      [NotNull] string deletedText
    )
    {
      if (symbolName == null) throw new ArgumentNullException("symbolName");
      if (deletedText == null) throw new ArgumentNullException("deletedText");
      
      SymbolName = symbolName;
      Found = found;
      DeletedText = deletedText;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string symbolName, out bool found, [NotNull] out string deletedText)
    {
      symbolName = SymbolName;
      found = Found;
      deletedText = DeletedText;
    }
    //statics
    
    public static CtxReadDelegate<DeletedSymbolEntry> Read = (ctx, reader) => 
    {
      var symbolName = reader.ReadString();
      var found = reader.ReadBool();
      var deletedText = reader.ReadString();
      var _result = new DeletedSymbolEntry(symbolName, found, deletedText);
      return _result;
    };
    
    public static CtxWriteDelegate<DeletedSymbolEntry> Write = (ctx, writer, value) => 
    {
      writer.Write(value.SymbolName);
      writer.Write(value.Found);
      writer.Write(value.DeletedText);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((DeletedSymbolEntry) obj);
    }
    public bool Equals(DeletedSymbolEntry other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return SymbolName == other.SymbolName && Found == other.Found && DeletedText == other.DeletedText;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + SymbolName.GetHashCode();
        hash = hash * 31 + Found.GetHashCode();
        hash = hash * 31 + DeletedText.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("DeletedSymbolEntry (");
      using (printer.IndentCookie()) {
        printer.Print("symbolName = "); SymbolName.PrintEx(printer); printer.Println();
        printer.Print("found = "); Found.PrintEx(printer); printer.Println();
        printer.Print("deletedText = "); DeletedText.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:86</p>
  /// </summary>
  public sealed class FindSymbolRequest : IPrintable, IEquatable<FindSymbolRequest>
  {
    //fields
    //public fields
    [NotNull] public string SymbolName {get; private set;}
    [NotNull] public string FilePath {get; private set;}
    
    //private fields
    //primary constructor
    public FindSymbolRequest(
      [NotNull] string symbolName,
      [NotNull] string filePath
    )
    {
      if (symbolName == null) throw new ArgumentNullException("symbolName");
      if (filePath == null) throw new ArgumentNullException("filePath");
      
      SymbolName = symbolName;
      FilePath = filePath;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string symbolName, [NotNull] out string filePath)
    {
      symbolName = SymbolName;
      filePath = FilePath;
    }
    //statics
    
    public static CtxReadDelegate<FindSymbolRequest> Read = (ctx, reader) => 
    {
      var symbolName = reader.ReadString();
      var filePath = reader.ReadString();
      var _result = new FindSymbolRequest(symbolName, filePath);
      return _result;
    };
    
    public static CtxWriteDelegate<FindSymbolRequest> Write = (ctx, writer, value) => 
    {
      writer.Write(value.SymbolName);
      writer.Write(value.FilePath);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((FindSymbolRequest) obj);
    }
    public bool Equals(FindSymbolRequest other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return SymbolName == other.SymbolName && FilePath == other.FilePath;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + SymbolName.GetHashCode();
        hash = hash * 31 + FilePath.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("FindSymbolRequest (");
      using (printer.IndentCookie()) {
        printer.Print("symbolName = "); SymbolName.PrintEx(printer); printer.Println();
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
  
  
  /// <summary>
  /// <p>Generated from: GameScriptModel.kt:102</p>
  /// </summary>
  public sealed class SymbolLocation : IPrintable, IEquatable<SymbolLocation>
  {
    //fields
    //public fields
    [NotNull] public string FilePath {get; private set;}
    public int StartLine {get; private set;}
    [NotNull] public string Text {get; private set;}
    [NotNull] public string Error {get; private set;}
    
    //private fields
    //primary constructor
    public SymbolLocation(
      [NotNull] string filePath,
      int startLine,
      [NotNull] string text,
      [NotNull] string error
    )
    {
      if (filePath == null) throw new ArgumentNullException("filePath");
      if (text == null) throw new ArgumentNullException("text");
      if (error == null) throw new ArgumentNullException("error");
      
      FilePath = filePath;
      StartLine = startLine;
      Text = text;
      Error = error;
    }
    //secondary constructor
    //deconstruct trait
    public void Deconstruct([NotNull] out string filePath, out int startLine, [NotNull] out string text, [NotNull] out string error)
    {
      filePath = FilePath;
      startLine = StartLine;
      text = Text;
      error = Error;
    }
    //statics
    
    public static CtxReadDelegate<SymbolLocation> Read = (ctx, reader) => 
    {
      var filePath = reader.ReadString();
      var startLine = reader.ReadInt();
      var text = reader.ReadString();
      var error = reader.ReadString();
      var _result = new SymbolLocation(filePath, startLine, text, error);
      return _result;
    };
    
    public static CtxWriteDelegate<SymbolLocation> Write = (ctx, writer, value) => 
    {
      writer.Write(value.FilePath);
      writer.Write(value.StartLine);
      writer.Write(value.Text);
      writer.Write(value.Error);
    };
    
    //constants
    
    //custom body
    //methods
    //equals trait
    public override bool Equals(object obj)
    {
      if (ReferenceEquals(null, obj)) return false;
      if (ReferenceEquals(this, obj)) return true;
      if (obj.GetType() != GetType()) return false;
      return Equals((SymbolLocation) obj);
    }
    public bool Equals(SymbolLocation other)
    {
      if (ReferenceEquals(null, other)) return false;
      if (ReferenceEquals(this, other)) return true;
      return FilePath == other.FilePath && StartLine == other.StartLine && Text == other.Text && Error == other.Error;
    }
    //hash code trait
    public override int GetHashCode()
    {
      unchecked {
        var hash = 0;
        hash = hash * 31 + FilePath.GetHashCode();
        hash = hash * 31 + StartLine.GetHashCode();
        hash = hash * 31 + Text.GetHashCode();
        hash = hash * 31 + Error.GetHashCode();
        return hash;
      }
    }
    //pretty print
    public void Print(PrettyPrinter printer)
    {
      printer.Println("SymbolLocation (");
      using (printer.IndentCookie()) {
        printer.Print("filePath = "); FilePath.PrintEx(printer); printer.Println();
        printer.Print("startLine = "); StartLine.PrintEx(printer); printer.Println();
        printer.Print("text = "); Text.PrintEx(printer); printer.Println();
        printer.Print("error = "); Error.PrintEx(printer); printer.Println();
      }
      printer.Print(")");
    }
    //toString
    public override string ToString()
    {
      var printer = new SingleLinePrettyPrinter();
      Print(printer);
      return printer.ToString();
    }
  }
}
